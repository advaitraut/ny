//custom main function, cna be used e.g. for an hardware acclerated game
//lot like sdl/sfml
//implement custom (3D) renderer
class MyRenderer : public ny::GlRenderer
{
};

//custom eventDispatcher -> custom mainLoop
class MyDispatcher : public ny::EventDispatcher
{
protected:
	virtual void sendEvent(const Event& event) override
	{
		//main loop here basically
		switch(event->type())
		{
			case ny::eventType::draw:
				MyRenderer.draw();
				break;

			case ny::eventType::exit:
				appContext->exit();
				break;

			default:
				break;
		}

		//default dispatch
		ny::EventDispatcher::sendEvent(event);
	}
};


//lowlevel main func
//does only require ny-base and ny-backend 
auto* backend = ny::queryBackend();
auto appContext = backend->createAppContext();
auto windowContext = backend->createWindowContext(*appContext);

MyDispatcher dispatcher;
appContext->run(dispatcher);

return 1;



//default main function, used e.g. for effecient gui programming
//more like conventional gtk/qt main loops
//highlevel main func
//does reuiqre ny-backend ny-base ny-app ny-window and ny-draw
//ny-gui can be easily integrated for convinient ui drawing

ny::App app;
ny::Frame frame(app, {800, 500});

frame.onDraw = [](ny::DrawContext& dc){ dc.clear(ny::Color::White); };

app.run();
return 1;


///minimalistic opengl
auto* backend = ny::queryBackend();
auto appContext = backend->createAppContext();
auto windowContext = backend->createWindowContext(*appContext);

ny::ThreadsafeEventDispatcher dispatcher;
appContext->runAsync(dispatcher);

ny::Event* event = nullptr;
while(1)
{
	while((event = dispatcher.pollEvent()))
	{
		if(event->type() == ny::eventType::quit)
			return 0;
	}

	auto& dc = windowContext.beginDraw();
	windowContext.finishDraw();
}


//#2 main loop
//requires that all backends are able to implement such a function
//could be problematic on some backends?
//technically combines the eventdispatcher system with a normal synchronous main loop (sfml like)
while(appContext->dispatch())
{
	draw(myWindow);
}

//#3 provide the same possibility for the App class
while(app.dispatch())
{
	draw(myWindow);
}


//question: how to draw on a window
//windows shall be always drawable, no matter if they have gotten a draw event or not
//most backends would require some kinda beginDraw() DRAW endDraw() construct
//really bad design, does not follow RAII
//what happens if beginDraw is called, exception is raised before endDraw cann be called?
//->not good
auto& dc = wc->beginDraw();
drawContent(dc);
wc->endDraw();

//some kind of draw token
//RAII class that automatically calls finish draw on destruction
//concept would be probably unnecessary hard and complex
//problem: one might call auto& dc = wc->beginDraw().drawContext()
//againt interface design rules -> easy to do wrong
auto token = wc->beginDraw();
drawContent(token.drawContext());

//does we really need endDraw? couldnt a call to DrawContext::init and DrawContext::apply
//be enough? if it isnt called after the draw calls the content might simplex not be applied?
//no need for beginDraw and replace it with an permanent drawContext?
//could again be problematic on some backends (i.e. winapi)
auto& dc = wc->drawContext();
dc.init();
drawContent(dc);
dc.apply();

//later on
dc.init();
drawContent(dc);
dc.apply();

//involve some conceptual problems with window drawing
//again does not follow raii
//does a window really have to be always drawable?

///////////////
//token possibility seems the most promising one, needs serious improvements.
//something like this?
ny::DrawToken token;
auto& dc = wc->drawContext(token);
drawContent(dc);

//the DrawContext guarantees to apply all drawn contents when the token is destructed
//the lifetime/validity of the DrawContext can be still determined by the implementation.
//Can all implementations implement a theoretically infinite lifetime of the DrawContext?
//probably
//So the interface should be able to require that the DrawContext is valid as long as the DrawToken 
//exists.
//Still provide the possibility for beginDraw/endDraw? is easier to understand for new users.
//Token system not that hard as well.
//Probably enough for the beginning.

//Problem: imagine opengl token implementation when tokens may have infinite lifetime.
//multiple tokens = multiple opengl contexts that are made current and make not current again?
//allow only one token per thread at the same time & only one token per drawContext/windowContext?


/////////77
//final syntax:
//manual:
auto& dc = wc->drawContext();
dc.init();
drawContent(dc);
dc.apply();

//raii, shall be used in tutorials and examples, generally recommended
auto& dc = wc->drawContext();
DrawGuard guard(dc);
drawContent(guard);

//alternative #1:
auto guard = wc->draw();
drawContent(guard.get());

//requires that this syntax is not allowed:
auto& dc = wc->draw().get();

//can this be done with c++11 value-type specifiers?
//does this work?

class DrawGuard
{
public:
	//...
	DrawContext& get() const &; //< only allow for lvalues
};

//does work indeed
//->using this syntax
