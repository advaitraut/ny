// Boost Software License - Version 1.0 - August 17th, 2003
//
// Copyright (c) 2015-2016 nyorain
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#pragma once

#include <nytl/vec.hpp>
#include <memory>
#include <cstring>

namespace image
{

enum class ColorChannel
{
	none,
	red,
	green,
	blue,
	alpha
};

using Format = std::array<std::pair<ColorChannel, uint8_t>, 9>;

unsigned int bitSize(const Format& format);
unsigned int byteSize(const Format& format);
Format toggleByteWordOrder(const Format& format);

constexpr Format rgba8888 {{
	{ColorChannel::red, 8},
	{ColorChannel::green, 8},
	{ColorChannel::blue, 8},
	{ColorChannel::alpha, 8},
}};

constexpr Format argb8888 {{
	{ColorChannel::alpha, 8},
	{ColorChannel::red, 8},
	{ColorChannel::green, 8},
	{ColorChannel::blue, 8},
}};

template<typename P> class BasicImage;

namespace detail
{
	template<typename P> auto data(P ptr) { return ptr; }
	template<typename P> auto data(std::unique_ptr<P> ptr) { return ptr.get(); }

	template<typename P>
	void copy(P& to, uint8_t* from, unsigned int) { to = from; }

	template<typename PT>
	void copy(std::unique_ptr<PT[]> to, uint8_t* from, unsigned int size)
	{
		if(!from)
		{
			to = {};
			return;
		}

		to = std::make_unique<PT[]>(size);
		std::memcpy(to.get(), from, size);
	}
}

template<typename P>
class BasicImage
{
public:
	BasicImage() = default;
	~BasicImage() = default;

	BasicImage(uint8_t& data, nytl::Vec2ui size, const Format& format, unsigned int stride)
		: size_(size), format_(format), stride_(stride)
		{ detail::copy(data_, &data, dataSize()); }

	BasicImage(P data, nytl::Vec2ui size, const Format& format, unsigned int stride)
		: data_(std::move(data)), size_(size), format_(format), stride_(stride) {}

	template<typename O>
	BasicImage(const BasicImage<O>& lhs)
	{
		size_ = lhs.size();
		format_ = lhs.format();
		stride_ = lhs.sitrde();
		detail::copy(data_, lhs.data(), lhs.dataSize());
	}

	template<typename O>
	BasicImage& operator=(const BasicImage<O>& lhs)
	{
		size_ = lhs.size();
		format_ = lhs.format();
		stride_ = lhs.sitrde();
		detail::copy(data_, lhs.data(), lhs.dataSize());
		return *this;
	}

	BasicImage(BasicImage&&) = default;
	BasicImage& operator=(BasicImage&&) = default;

	nytl::Vec2ui size() const { return size_; }
	Format format() const { return format_; }
	unsigned int stride() const;
	unsigned int dataSize() const { return stride() * size().y; }

	uint8_t* data() { return detail::data(data_); }
	const uint8_t* data() const { return detail::data(data_); }

	P& dataPtr() { return data_; }
	const P& dataPtr() const { return data_; }

	///Changes the format interpretation of this image.
	///Will throw std::logic_error if the format size is greater than the current format.
	void format(const Format& format);

protected:
	P data_ {}; //raw image data. At least dataSize() bytes.
	nytl::Vec2ui size_ {}; //size in pixels.
	Format format_ {}; //data format in word order (endian-native).
	unsigned int stride_ {}; //stride in bits.
};

using Image = BasicImage<const uint8_t*>;
using MutableImage = BasicImage<uint8_t*>;
using OwnedImage = BasicImage<std::unique_ptr<uint8_t[]>>;

///Returns the color of the image at at the given position.
///Does not perform any range checking, i.e. if position lies outside of the size
///of the passed ImageData object, this call will result in undefined behavior.
nytl::Vec4u8 readPixel(const Image&, nytl::Vec2ui position);
nytl::Vec4u8 readPixel(const uint8_t& pixel, const Format& format);

///Sets the color of the pixel at the given position.
///Does not perform any range checking, i.e. if position lies outside of the size
///of the passed ImageData object, this call will result in undefined behavior.
void writePixel(const MutableImage&, nytl::Vec2ui position, nytl::Vec4u8 color);
void writePixel(uint8_t& pixel, const Format& format, nytl::Vec4u8 color);

bool littleEndian();

nytl::Vec4u8 readPixel(const uint8_t& pixel, const Format& format)
{
	const uint8_t* iter = &pixel;
	nytl::Vec4u64 rgba {};
	auto bitOffset = 0u;

	for(auto i = 0u; i < format.size(); ++i)
	{
		auto channel = format[i];
		unsigned int byteCount = std::ceil(channel.second + bitOffset / 8u);
		byteCount = std::max(8u, byteCount); //we can't read more than 8 bytes

		uint64_t* val {};
		switch(channel.first)
		{
			case ColorChannel::red: val = &rgba[0]; break;
			case ColorChannel::green: val = &rgba[1]; break;
			case ColorChannel::blue: val = &rgba[2]; break;
			case ColorChannel::alpha: val = &rgba[3]; break;
			case ColorChannel::none: iter += byteCount; continue;
		}

		//load the first byteCount bytes as least significant bytes into *val
		if(littleEndian()) for(auto b = 0u; b < byteCount; ++b) val[b] = *(iter++);
		else for(auto b = 0u; b < byteCount; ++b) val[byteCount - (b + 1)] = *(iter++);

		//create a bitmask with the least significant channel.second bites set to 1
		uint64_t bitmask = 0u;
		for(auto m = 0u; m < channel.second && m < 64; ++m) bitmask |= (1 << m);

		//discard all bits from *val that are not in the range of the current channel
		*val = (*val >> bitOffset) & bitmask;

		//advance the bitOffset by the bits we read into the next byte.
		bitOffset = channel.second % 8;
	}

	return rgba;
}

void writePixel(uint8_t& pixel, const Format& format, nytl::Vec4u8 color)
{
	auto pixelSize = byteSize(format);
}

}
