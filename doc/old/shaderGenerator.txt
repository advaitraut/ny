class GeneratedShader
{
public:
	struct Var
	{
		std::string type;
		std::string name;
	};

	struct Input : Var {};
	struct Output : Var {};
	struct Uniform : Var {};
	struct DynamicUniformArray : Var
	{
		std::string parameterName;
	};

	struct Version
	{
		GlContext::Api api;
		unsigned int major;
		unsigned int minor;
	};

protected:
	std::string code_;

public:
	GeneratedShader(const std::string& code = "") : code_(code) {};	
	
	void code(const std::string& text);
	std::string& code() { return code_; }
	const std::string& code() const { return code_; }

	virtual void generate(Version version) = 0;
};


//////
{

constexpr auto defaultVS = 
	R"SRC(

	%i vec2 position;
	%u vec3 vViewSize;
	%u mat3 vTransform;
	
	void main()
	{
        vec3 transpoint = vec3(position, 1.f) * vTransform;
        transpoint.x = (transpoint.x / vViewSize.x) * 2.f - 1.f;
        transpoint.y = ((vViewSize.y - transpoint.y) / vViewSize.y) * 2.f - 1.f;
        gl_Position = vec4(transpoint, 1.f);
	}

	)SRC"

constexpr auto colorFS = 
	R"SRC(

	%u vec4 fColor;
	%colorOutputVar vec4 outColor;
	
	void main()
	{
        %colorOutput = vec4(transpoint, 1.f);
	}

	)SRC"

GeneratedVertexShader vsSource(defaultVS);
GeneratedFragmentShader fsSource(colorFS);

auto vsCode = vsSource.generate({GlContext::api::openGL, 3, 2});
auto fsCode = fsSource.generate({GlContext::api::openGL, 3, 2});

Shader myShader;
myShader.addStage(Shader::Type::Vertex, vsCode);
myShader.addStage(Shader::Type::Fragment, fsCode);
myShader.compile();

//draw
myShader.use();

}





