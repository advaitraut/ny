//polymorphic events, still cloneable to be able to store them (e.g. in a mouse grab)

//eventType
//custom events should put their type id in this namespace
namespace eventType
{
constexpr unsigned int invalid = 0;
constexpr unsigned int destroy = 1;
}

//eventData, used by backends
class eventData
{
public:
    virtual ~eventData(){}; //for dynamic cast
};

//event//////////////////
class event
{
public:
    event(eventHandler* xhandler = nullptr, eventData* xdata = nullptr) : handler(xhandler), data(xdata) {};
    virtual ~event() = default;

    eventHandler* handler {nullptr};
    std::unique_ptr<eventData> data {nullptr}; //place for the backend to transport data (e.g. serial numbers for custom resize / move), todo: unique ptr

    //cast
    template<class T> T& to()
    {
        return static_cast<T&>(*this);
    };

    //clone
    virtual std::unique_ptr<event> clone() const = 0;
    virtual unsigned int type() const = 0;
};

//eventBase, should be used when deriving events
template<typename T, unsigned int Type> class eventBase : public event
{
protected:
    using evBase = eventBase<T, Type>;

public:
    eventBase(eventHandler* xhandler = nullptr, eventData* xdata = nullptr) : event(xhandler, xdata){};

    virtual std::unique_ptr<event> clone() const override { return new T(static_cast<const T&>(*this)); }
    virtual unsigned int type() const override { return Type; }
};

//destoyEvent
class destroyEvent : public eventBase<destroyEvent, eventType::destroy>
{
public:
    destroyEvent(eventHandler* h, eventData* d = nullptr) : evBase(h, d) {}
};



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//problem: data member (unique_ptr), must be cloneable too











//events2 - backup////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#pragma once

#include <ny/include.hpp>

#include <memory>
#include <type_traits>

namespace ny
{

//eventType
//custom events should put their type id in this namespace
namespace eventType
{
constexpr unsigned int invalid = 0;
constexpr unsigned int destroy = 1;
}

//eventData, used by backends
class eventData
{
public:
    virtual ~eventData() = default; //for dynamic cast
    virtual std::unique_ptr<eventData> clone() const = 0;
};

template <typename T>
class eventDataBase
{
public:
    virtual std::unique_ptr<eventData> clone() const override
        { return std::make_unique<T>(static_cast<T&>(*this)); }
};

//event//////////////////
class event
{
public:
    event(eventHandler* h = nullptr, eventData* d = nullptr) : handler(h), data(d) {};
    virtual ~event() = default;

    event(const event& other) : handler(other.handler), data(nullptr) { if(other.data.get()) data = other.data->clone(); }
    event& operator=(const event& other)
    {
        handler = other.handler;
        if(other.data.get()) data = other.data->clone();
        else data.reset();
        return *this;
    }

    event(event&& other) : handler(other.handler), data(std::move(other.data)) {}
    event& operator=(event&& other) { handler = other.handler; data = std::move(other.data); return *this; }

    eventHandler* handler {nullptr};
    std::unique_ptr<eventData> data {nullptr}; //place for the backend to transport data (e.g. serial numbers for custom resize / move)

    //type
    virtual std::unique_ptr<event> clone() const = 0;
    virtual unsigned int type() const = 0;
};

//eventBase
template<typename T, unsigned int Type>
class eventBase : public event
{
protected:
    using evBase = eventBase<Type>;

public:
    eventBase(eventHandler* xhandler = nullptr, eventData* xdata = nullptr) : event(xhandler, xdata){};

    //event
    virtual std::unique_ptr<event> clone() const override
        { return std::make_unique<T>(static_cast<T&>(*this)); }
    virtual unsigned int type() const override final { return Type; }
};

//destroy
class destroyEvent : public eventBase<destroyEvent, eventType::destroy>
{
public:
    destroyEvent(eventHandler* h = nullptr, eventData* d = nullptr) : evBase(h, d) {};
};


//event cast
template<typename T>
std::unique_ptr<T> event_cast(std::unique_ptr<event>&& ptr)
{
    static_assert(std::is_base_of<event, T>::value, "you can only cast into a derived event class");
    return std::unique_ptr<T>(dynamic_cast<T*>(ptr.release())); //better static_cast?
}













class EventTypeRegister
{
public:
	EventTypeRegister& instance();

public:
	std::string name(unsigned int type);
	unsigned int id(const std::string& name);

	bool registered(unsigned int type);
	unsigned int register(const std::string& name, unsigned int pref = 0);
	unsigned int registerPref(const std::string& name, unsigned int pref);
};

static auto eventTypeClose = EventTypeRegister::instance().register("ny::eventType::close");
