// Boost Software License - Version 1.0 - August 17th, 2003
//
// Copyright (c) 2015-2016 nyorain
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#pragma once

#include <nytl/vec.hpp>
#include <memory>
#include <cstring>
#include <bitset>

//TODO: c++17 make ImageFormat pod struct derived from std::array and
//  the default formats constexpr members (i.e. ImageFormat::rgba8888)
//  make also the utility functions constexpr

namespace image
{

///Represents a ColorChannel for an ImageFormat specification.
enum class ColorChannel
{
	none,
	red,
	green,
	blue,
	alpha
};

///An ImageFormat specifies the way the colors of an Image pixel is interpreted.
///It specifies the different used color channels and their size in bits.
///For offsets ColorChannel::none can be used. All other ColorChannels are allowed
///to appear only once per format (e.g. there can't be 8 red bits then 8 green bits and
///then 8 red bits again for one pixel).
using ImageFormat = std::array<std::pair<ColorChannel, uint8_t>, 9>;

// - Default formats -
constexpr ImageFormat rgba8888 {{
	{ColorChannel::red, 8},
	{ColorChannel::green, 8},
	{ColorChannel::blue, 8},
	{ColorChannel::alpha, 8},
}};

constexpr ImageFormat argb8888 {{
	{ColorChannel::alpha, 8},
	{ColorChannel::red, 8},
	{ColorChannel::green, 8},
	{ColorChannel::blue, 8},
}};

constexpr ImageFormat a8 {{{ColorChannel::alpha, 8}}};
constexpr ImageFormat a4 {{{ColorChannel::alpha, 4}}};
constexpr ImageFormat a1 {{{ColorChannel::alpha, 1}}};

///Returns whether the current machine is little endian.
///If this returns false it is assumed to be big endian (other types are ignored).
constexpr bool littleEndian();

///Returns the next multiple of alignment that is greater or equal than value.
///Can be used to 'align' a value e.g. align(27, 8) returns 32.
template<typename A, typename B>
constexpr auto align(A value, B alignment)
	{ return std::ceil(value / double(alignment)) * alignment; }

///Returns the number of bits needed to store one pixel in the given format.
unsigned int bitSize(const ImageFormat& format);

///Returns the number of bytes needed to store one pixel in the given format.
///Sine the exact value might not be a multiple of one byte, this value is rouneded up.
///Example: byteSize(ImageFormat::)
unsigned int byteSize(const ImageFormat& format);

///Converts between byte order (i.e. endian-independent) and word-order (endian-dependent)
///and vice versa. On a big-endian machine this function will simply return the given format, but
///on a little-endian machine it will reverse the order of the color channels..
///Note that BasicImage objects always hold data in word order, so if one works with a library
///that uses byte-order (as some e.g. image libraries do) they have to either convert the
///data or the format when passing/receiving from/to this library.
ImageFormat toggleByteWordOrder(const ImageFormat& format);

namespace detail
{
	template<typename P>
	void copy(P& to, uint8_t* from, unsigned int) { to = from; }

	template<typename PT>
	void copy(std::unique_ptr<PT[]> to, uint8_t* from, unsigned int size)
	{
		if(!from)
		{
			to = {};
			return;
		}

		to = std::make_unique<PT[]>(size);
		std::memcpy(to.get(), from, size);
	}
}

///Used to pass loaded or created images to functions.
///Note that this class does explicitly not implement any functions for creating/loading/changing
///the image itself, it is only used to hold all information needed to correctly interpret
///a raw image data buffer.
///Its stride is stored in bits and therefore the image stride might not be a multiple
///of 8 bits (1 byte).
///There are several helper functions that make dealing with BasicImage objects easier.
///\tparam P The pointer type to used. Should be a type that can be used as std::uint8_t*.
///Might be const or a smart pointer.
template<typename P>
class BasicImage
{
public:
	BasicImage() = default;
	~BasicImage() = default;

	BasicImage(uint8_t& xdata, nytl::Vec2ui xsize, const ImageFormat& fmt, unsigned int strd = 0u)
		: size(xsize), format(fmt), stride(strd)
	{
		if(!stride) stride = size.x * bitSize(format);
		detail::copy(data, &xdata, dataSize(*this));
	}

	BasicImage(P xdata, nytl::Vec2ui xsize, const ImageFormat& fmt, unsigned int strd = 0u)
		: data(std::move(xdata)), size(xsize), format(fmt), stride(strd)
		{ if(!stride) stride = std::ceil(size.x * bitSize(format) / 8) * 8; }

	template<typename O>
	BasicImage(const BasicImage<O>& lhs)
		: size(lhs.size()), format(lhs.format()), stride(lhs.stride())
		{ detail::copy(data, lhs.data(), lhs.dataSize()); }

	template<typename O>
	BasicImage& operator=(const BasicImage<O>& lhs)
	{
		size = lhs.size;
		format = lhs.format;
		stride = lhs.sitrde;
		detail::copy(data, lhs.data(), lhs.dataSize());
		return *this;
	}

	BasicImage(BasicImage&&) = default;
	BasicImage& operator=(BasicImage&&) = default;

public:
	P data {}; //raw image data. At least dataSize() bytes.
	nytl::Vec2ui size {}; //size in pixels.
	ImageFormat format {}; //data format in word order (endian-native).
	unsigned int stride {}; //stride in bits.
};

using Image = BasicImage<const uint8_t*>;
using MutableImage = BasicImage<uint8_t*>;
using OwnedImage = BasicImage<std::unique_ptr<uint8_t[]>>;

///Returns the raw data from the given BasicImage as uint8_t pointer.
///Useful for generic code since it allows to access the raw data independently from the medium
///used to store it (could e.g. be a std::unique_ptr).
template<typename P>
const uint8_t* data(const BasicImage<P>& img)
	{ return img.data; }

template<typename P>
const uint8_t* data(const BasicImage<std::unique_ptr<P>>& img)
	{ return img.data.get(); }

///Returns the stride of the given BasicImage in bits.
///If the given image has no stride stored, calculates the stride.
template<typename P>
unsigned int bitStride(const BasicImage<P>& img)
	{ return img.stride ? img.stride : img.size.x * bitSize(img.format); }

///Returns the stride of the given BasicImage in bytes (rounded up).
///If the given image has no stride stored, calculates the stride.
template<typename P>
unsigned int byteStride(const BasicImage<P>& img)
	{ return img.stride ? std::ceil(img.stride / 8) : img.size.x * byteSize(img.format); }

///Returns the total amount of bytes the image data holds (rounded up).
template<typename P>
unsigned int dataSize(const BasicImage<P>& img)
	{ return std::ceil(bitStride(img) * img.size.y / 8.0); }

///Returns the color of the image at at the given position.
///Does not perform any range checking, i.e. if position lies outside of the size
///of the passed ImageData object, this call will result in undefined behavior.
nytl::Vec4u64 readPixel(const Image&, nytl::Vec2ui position);

///Returns the color of the given pixel value for the given ImageFormat.
///Results in undefined behaviour if the given format is invalid or the data referenced
///by pixel does not have enough bytes to read.
///\param bitOffset The bit position at which reading should start.
nytl::Vec4u64 readPixel(const uint8_t& pixel, const ImageFormat&, unsigned int bitOffset = 0u);

///Sets the color of the pixel at the given position.
///Does not perform any range checking, i.e. if position lies outside of the size
///of the passed ImageData object, this call will result in undefined behavior.
void writePixel(const MutableImage&, nytl::Vec2ui position, nytl::Vec4u8 color);

///Sets the color of the given pixel.
///Results in undefined behaviour if the given format is invalid or the data referenced
///by pixel does not have enough bytes to read.
///\param bitOffset The bit position at which reading should start.
void writePixel(uint8_t& pixel, const ImageFormat&, nytl::Vec4u64 color,
	unsigned int bitOffset = 0u);


/// - implementation -
constexpr bool littleEndian()
{
	constexpr uint32_t dummy = 1u;
	return (((std::uint8_t*)&dummy)[0] == 1);
}

unsigned int bitSize(const ImageFormat& format)
{
	auto ret = 0u;
	for(auto& channel : format) ret += channel.second;
	return ret;
}

unsigned int byteSize(const ImageFormat& format)
{
	return std::ceil(bitSize(format) / 8.0);
}

ImageFormat toggleByteWordOrder(const ImageFormat& format)
{
	if(!littleEndian()) return format;

	auto copy = format;
	auto begin = copy.begin();
	auto end = copy.end();

	//ignore "empty" channels (channels with size of 0)
	//otherwise toggles formats would maybe begin with x empty channels
	//which would be valid but really ugly
	while((begin != end) && (!begin->second)) ++begin;
	while((end != (begin + 1) && (!(end - 1)->second))) --end;

	std::reverse(begin, end);
	return copy;
}

nytl::Vec4u64 readPixel(const uint8_t& pixel, const ImageFormat& format, unsigned int bitOffset)
{
	const uint8_t* iter = &pixel;
	nytl::Vec4u64 rgba {};

	for(auto i = 0u; i < format.size(); ++i)
	{
		//for little endian channel order is inversed
		auto channel = (littleEndian()) ? format[format.size() - (i + 1)] : format[i];
		if(!channel.second) continue;

		//calculate the byte count we have to load at all for this channel
		unsigned int byteCount = std::ceil(channel.second / 8.0);

		uint64_t* val {};
		switch(channel.first)
		{
			case ColorChannel::red: val = &rgba[0]; break;
			case ColorChannel::green: val = &rgba[1]; break;
			case ColorChannel::blue: val = &rgba[2]; break;
			case ColorChannel::alpha: val = &rgba[3]; break;
			case ColorChannel::none: iter += byteCount; continue;
		}

		//reset the color value
		*val = {};

		//we want to read from &pixel:bitOffset to &pixel:channel.second+bitOffset, i.e.
		//&pixel+byteCount:bitOffset

		auto startByte = &pixel;
		auto startBit = bitOffset;
		auto endByte = &pixel + (channel.second + bitOffset) / 8;
		auto endBit = (channel.second + bitOffset) % 8;

		//we load the bytes read from pixel into the return value for the current color channel
		//note than we want to achieve the smallest significance overall while preserving
		//byte significance between bytes of one color channel
		//we do this because we may load less than 8 bytes and e.g. 0xFF should result in
		//a color value of 0xFF and not 0xFF00000000000000
		//Furthermore should 0xAABB result in 0xAABB.
		auto bytes = reinterpret_cast<uint8_t*>(val);
		if(littleEndian()) for(auto b = 0u; b < byteCount; ++b) bytes[b] = *(iter + b);
		else for(auto b = 0u; b < byteCount; ++b) bytes[8 - byteCount + b] = *(iter + b);

		//shift the bits
		//i.e. shift away the least signifance bitOffset bytes
		//note than >> does NOT mean a right shift on little endian
		if(littleEndian() && bitOffset) *val >>= bitOffset;
		else if(!littleEndian() && (channel.second % 8u)) *val >>= (8 - channel.second % 8);

		//if bitOffset was great enough another byte has to be loaded.
		//done this complex since sometimes we e.g. might have to load 9 bytes
		if(std::ceil((channel.second + bitOffset) / 8.0) > byteCount)
		{
			std::uint64_t tmp {};
			auto tmpBytes = reinterpret_cast<uint8_t*>(val);

			if(littleEndian()) bytes[byteCount - 1] = *(iter + byteCount);
			else
			{
				tmpBytes[7] = *(iter + byteCount);
				*val <<= bitOffset;
				*val |= (tmp >> (8 - (channel.second + bitOffset) % 8));
			}
		}

		//create a bitmask with the least significant channel.second bites set to 1
		//and then discard all bits from *val that are not in the range of the current channel
		if(channel.second != 64)
		{
			uint64_t bitmask = 0u;
			for(auto m = 0u; m < channel.second && m < 64; ++m) bitmask |= (1 << m);
			*val &= bitmask;
		}

		//advance the bitOffset by the bits we read into the next byte.
		auto newOffset = (bitOffset + channel.second) % 8u;
		iter += static_cast<unsigned int>(std::floor(channel.second / 8) + (newOffset < bitOffset));
		bitOffset = newOffset;
	}

	return rgba;
}

nytl::Vec4f norm(nytl::Vec4u64 color, const ImageFormat& format)
{
	nytl::Vec4f ret = color;

	for(auto& channel : format)
	{
		if(!channel.second) continue;

		switch(channel.first)
		{
			case ColorChannel::red: ret[0] /= std::exp2(channel.second) - 1; break;
			case ColorChannel::green: ret[1] /= std::exp2(channel.second) - 1; break;
			case ColorChannel::blue: ret[2] /= std::exp2(channel.second) - 1; break;
			case ColorChannel::alpha: ret[3] /= std::exp2(channel.second) - 1; break;
			case ColorChannel::none: continue;
		}
	}

	return ret;
}

void writePixel(uint8_t& pixel, const ImageFormat& format, nytl::Vec4u8 color,
	unsigned int bitOffset)
{
	auto pixelSize = byteSize(format);
}

nytl::Vec4u64 readPixel2(const uint8_t& pixel, const ImageFormat& format, unsigned int bitOffset = 0)
{
	const uint8_t* iter = &pixel;
	nytl::Vec4u64 rgba {};

	for(auto i = 0u; i < format.size(); ++i)
	{
		//for little endian channel order is inversed
		auto channel = (littleEndian()) ? format[format.size() - (i + 1)] : format[i];
		if(!channel.second) continue;

		//calculate the byte count we have to load at all for this channel
		unsigned int byteCount = std::ceil(channel.second / 8.0);

		uint64_t* val {};
		switch(channel.first)
		{
			case ColorChannel::red: val = &rgba[0]; break;
			case ColorChannel::green: val = &rgba[1]; break;
			case ColorChannel::blue: val = &rgba[2]; break;
			case ColorChannel::alpha: val = &rgba[3]; break;
			case ColorChannel::none: iter += byteCount; continue;
		}

		//reset the color value
		*val = {};

		//we want to read from &pixel:bitOffset to &pixel:channel.second+bitOffset, i.e.
		//&pixel+byteCount:bitOffset
		//
		// auto startByte = &pixel;
		// auto startBit = bitOffset;
		// auto endByte = &pixel + (channel.second + bitOffset) / 8;
		// auto endBit = (channel.second + bitOffset) % 8;

		//least significant bits/bytes (with data) first
		std::bitset<64> bitset {};

		if(littleEndian())
		{
			for(auto i = 0u; i < channel.second; ++i)
			{
				bitset[i] = (*iter & (1 << bitOffset));

				++bitOffset;
				if(bitOffset >= 8)
				{
					++iter;
					bitOffset = 0;
				}
			}
		}
		else
		{
			for(auto i = 0u; i < channel.second; ++i)
			{
				bitset[56 - (i / 8) + bitOffset] = (*iter & (1 << bitOffset));

				++bitOffset;
				if(bitOffset >= 8)
				{
					++iter;
					++byteCount;
					bitOffset = 0;
				}
			}
		}

		auto ullong = bitset.to_ullong();
		*val = ullong;
		continue;

		//we load the bytes read from pixel into the return value for the current color channel
		//note than we want to achieve the smallest significance overall while preserving
		//byte significance between bytes of one color channel
		//we do this because we may load less than 8 bytes and e.g. 0xFF should result in
		//a color value of 0xFF and not 0xFF00000000000000
		//Furthermore should 0xAABB result in 0xAABB.
		auto bytes = reinterpret_cast<uint8_t*>(val);
		if(littleEndian()) for(auto b = 0u; b < byteCount; ++b) bytes[b] = *(iter + b);
		else for(auto b = 0u; b < byteCount; ++b) bytes[8 - byteCount + b] = *(iter + b);

		//shift the bits
		//i.e. shift away the least signifance bitOffset bytes
		//note than >> does NOT mean a right shift on little endian
		if(littleEndian() && bitOffset) *val >>= bitOffset;
		else if(!littleEndian() && (channel.second % 8u)) *val >>= (8 - channel.second % 8);

		//if bitOffset was great enough another byte has to be loaded.
		//done this complex since sometimes we e.g. might have to load 9 bytes
		if(std::ceil((channel.second + bitOffset) / 8.0) > byteCount)
		{
			std::uint64_t tmp {};
			auto tmpBytes = reinterpret_cast<uint8_t*>(val);

			if(littleEndian()) bytes[byteCount - 1] = *(iter + byteCount);
			else
			{
				tmpBytes[7] = *(iter + byteCount);
				*val <<= bitOffset;
				*val |= (tmp >> (8 - (channel.second + bitOffset) % 8));
			}
		}

		//create a bitmask with the least significant channel.second bites set to 1
		//and then discard all bits from *val that are not in the range of the current channel
		if(channel.second != 64)
		{
			uint64_t bitmask = 0u;
			for(auto m = 0u; m < channel.second && m < 64; ++m) bitmask |= (1 << m);
			*val &= bitmask;
		}

		//advance the bitOffset by the bits we read into the next byte.
		auto newOffset = (bitOffset + channel.second) % 8u;
		iter += static_cast<unsigned int>(std::floor(channel.second / 8) + (newOffset < bitOffset));
		bitOffset = newOffset;
	}

	return rgba;
}

}
