// Boost Software License - Version 1.0 - August 17th, 2003
//
// Copyright (c) 2015-2016 nyorain
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#pragma once

#include <nytl/vec.hpp>
#include <memory>
#include <cstring>
#include <bitset>

//TODO: c++17 make ImageFormat pod struct derived from std::array and
//  the default formats constexpr members (i.e. ImageFormat::rgba8888)
//  make also the utility functions constexpr

namespace image
{

///Represents a ColorChannel for an ImageFormat specification.
enum class ColorChannel
{
	none,
	red,
	green,
	blue,
	alpha
};

///An ImageFormat specifies the way the colors of an Image pixel is interpreted.
///It specifies the different used color channels and their size in bits.
///For offsets ColorChannel::none can be used. All other ColorChannels are allowed
///to appear only once per format (e.g. there can't be 8 red bits then 8 green bits and
///then 8 red bits again for one pixel).
using ImageFormat = std::array<std::pair<ColorChannel, uint8_t>, 9>;

// - Default formats -
constexpr ImageFormat rgba8888 {{
	{ColorChannel::red, 8},
	{ColorChannel::green, 8},
	{ColorChannel::blue, 8},
	{ColorChannel::alpha, 8},
}};

constexpr ImageFormat argb8888 {{
	{ColorChannel::alpha, 8},
	{ColorChannel::red, 8},
	{ColorChannel::green, 8},
	{ColorChannel::blue, 8},
}};

constexpr ImageFormat a8 {{{ColorChannel::alpha, 8}}};
constexpr ImageFormat a4 {{{ColorChannel::alpha, 4}}};
constexpr ImageFormat a1 {{{ColorChannel::alpha, 1}}};

///Returns whether the current machine is little endian.
///If this returns false it is assumed to be big endian (other types are ignored).
constexpr bool littleEndian();

///Returns the next multiple of alignment that is greater or equal than value.
///Can be used to 'align' a value e.g. align(27, 8) returns 32.
template<typename A, typename B>
constexpr auto align(A value, B alignment)
	{ return std::ceil(value / double(alignment)) * alignment; }

///Returns the number of bits needed to store one pixel in the given format.
unsigned int bitSize(const ImageFormat& format);

///Returns the number of bytes needed to store one pixel in the given format.
///Sine the exact value might not be a multiple of one byte, this value is rouneded up.
///Example: byteSize(ImageFormat::)
unsigned int byteSize(const ImageFormat& format);

///Converts between byte order (i.e. endian-independent) and word-order (endian-dependent)
///and vice versa. On a big-endian machine this function will simply return the given format, but
///on a little-endian machine it will reverse the order of the color channels..
///Note that BasicImage objects always hold data in word order, so if one works with a library
///that uses byte-order (as some e.g. image libraries do) they have to either convert the
///data or the format when passing/receiving from/to this library.
ImageFormat toggleByteWordOrder(const ImageFormat& format);

namespace detail
{
	template<typename P>
	void copy(P& to, uint8_t* from, unsigned int) { to = from; }

	template<typename PT>
	void copy(std::unique_ptr<PT[]> to, uint8_t* from, unsigned int size)
	{
		if(!from)
		{
			to = {};
			return;
		}

		to = std::make_unique<PT[]>(size);
		std::memcpy(to.get(), from, size);
	}
}

///Used to pass loaded or created images to functions.
///Note that this class does explicitly not implement any functions for creating/loading/changing
///the image itself, it is only used to hold all information needed to correctly interpret
///a raw image data buffer.
///Its stride is stored in bits and therefore the image stride might not be a multiple
///of 8 bits (1 byte).
///There are several helper functions that make dealing with BasicImage objects easier.
///\tparam P The pointer type to used. Should be a type that can be used as std::uint8_t*.
///Might be const or a smart pointer.
template<typename P>
class BasicImage
{
public:
	BasicImage() = default;
	~BasicImage() = default;

	BasicImage(uint8_t& xdata, nytl::Vec2ui xsize, const ImageFormat& fmt, unsigned int strd = 0u)
		: size(xsize), format(fmt), stride(strd)
	{
		if(!stride) stride = size.x * bitSize(format);
		detail::copy(data, &xdata, dataSize(*this));
	}

	BasicImage(P xdata, nytl::Vec2ui xsize, const ImageFormat& fmt, unsigned int strd = 0u)
		: data(std::move(xdata)), size(xsize), format(fmt), stride(strd)
		{ if(!stride) stride = std::ceil(size.x * bitSize(format) / 8) * 8; }

	template<typename O>
	BasicImage(const BasicImage<O>& lhs)
		: size(lhs.size()), format(lhs.format()), stride(lhs.stride())
		{ detail::copy(data, lhs.data(), lhs.dataSize()); }

	template<typename O>
	BasicImage& operator=(const BasicImage<O>& lhs)
	{
		size = lhs.size;
		format = lhs.format;
		stride = lhs.sitrde;
		detail::copy(data, lhs.data(), lhs.dataSize());
		return *this;
	}

	BasicImage(BasicImage&&) = default;
	BasicImage& operator=(BasicImage&&) = default;

public:
	P data {}; //raw image data. At least dataSize() bytes.
	nytl::Vec2ui size {}; //size in pixels.
	ImageFormat format {}; //data format in word order (endian-native).
	unsigned int stride {}; //stride in bits.
};

using Image = BasicImage<const uint8_t*>;
using MutableImage = BasicImage<uint8_t*>;
using OwnedImage = BasicImage<std::unique_ptr<uint8_t[]>>;

///Returns the raw data from the given BasicImage as uint8_t pointer.
///Useful for generic code since it allows to access the raw data independently from the medium
///used to store it (could e.g. be a std::unique_ptr).
template<typename P>
const uint8_t* data(const BasicImage<P>& img)
	{ return img.data; }

template<typename P>
const uint8_t* data(const BasicImage<std::unique_ptr<P>>& img)
	{ return img.data.get(); }

///Returns the stride of the given BasicImage in bits.
///If the given image has no stride stored, calculates the stride.
template<typename P>
unsigned int bitStride(const BasicImage<P>& img)
	{ return img.stride ? img.stride : img.size.x * bitSize(img.format); }

///Returns the stride of the given BasicImage in bytes (rounded up).
///If the given image has no stride stored, calculates the stride.
template<typename P>
unsigned int byteStride(const BasicImage<P>& img)
	{ return img.stride ? std::ceil(img.stride / 8) : img.size.x * byteSize(img.format); }

///Returns the total amount of bytes the image data holds (rounded up).
template<typename P>
unsigned int dataSize(const BasicImage<P>& img)
	{ return std::ceil(bitStride(img) * img.size.y / 8.0); }

///Returns the color of the image at at the given position.
///Does not perform any range checking, i.e. if position lies outside of the size
///of the passed ImageData object, this call will result in undefined behavior.
nytl::Vec4u64 readPixel(const Image&, nytl::Vec2ui position);

///Returns the color of the given pixel value for the given ImageFormat.
///Results in undefined behaviour if the given format is invalid or the data referenced
///by pixel does not have enough bytes to read.
///\param bitOffset The bit position at which reading should start.
nytl::Vec4u64 readPixel(const uint8_t& pixel, const ImageFormat&, unsigned int bitOffset = 0u);

///Sets the color of the pixel at the given position.
///Does not perform any range checking, i.e. if position lies outside of the size
///of the passed ImageData object, this call will result in undefined behavior.
void writePixel(const MutableImage&, nytl::Vec2ui position, nytl::Vec4u8 color);

///Sets the color of the given pixel.
///Results in undefined behaviour if the given format is invalid or the data referenced
///by pixel does not have enough bytes to read.
///\param bitOffset The bit position at which reading should start.
void writePixel(uint8_t& pixel, const ImageFormat&, nytl::Vec4u64 color,
	unsigned int bitOffset = 0u);


/// - implementation -
constexpr bool littleEndian()
{
	constexpr uint32_t dummy = 1u;
	return (((std::uint8_t*)&dummy)[0] == 1);
}

unsigned int bitSize(const ImageFormat& format)
{
	auto ret = 0u;
	for(auto& channel : format) ret += channel.second;
	return ret;
}

unsigned int byteSize(const ImageFormat& format)
{
	return std::ceil(bitSize(format) / 8.0);
}

ImageFormat toggleByteWordOrder(const ImageFormat& format)
{
	if(!littleEndian()) return format;

	auto copy = format;
	auto begin = copy.begin();
	auto end = copy.end();

	//ignore "empty" channels (channels with size of 0)
	//otherwise toggles formats would maybe begin with x empty channels
	//which would be valid but really ugly
	while((begin != end) && (!begin->second)) ++begin;
	while((end != (begin + 1) && (!(end - 1)->second))) --end;

	std::reverse(begin, end);
	return copy;
}

nytl::Vec4u64 readPixel(const uint8_t& pixel, const ImageFormat& format, unsigned int bitOffset = 0)
{
	const uint8_t* iter = &pixel;
	nytl::Vec4u64 rgba {};

	for(auto i = 0u; i < format.size(); ++i)
	{
		//for little endian channel order is inversed
		auto channel = (littleEndian()) ? format[format.size() - (i + 1)] : format[i];
		if(!channel.second) continue;

		//calculate the byte count we have to load at all for this channel
		unsigned int byteCount = std::ceil(channel.second / 8.0);

		uint64_t* val {};
		switch(channel.first)
		{
			case ColorChannel::red: val = &rgba[0]; break;
			case ColorChannel::green: val = &rgba[1]; break;
			case ColorChannel::blue: val = &rgba[2]; break;
			case ColorChannel::alpha: val = &rgba[3]; break;
			case ColorChannel::none: iter += byteCount; continue;
		}

		//reset the color value
		*val = {};

		//the bitset should store least significant bits/bytes (with data) first
		std::bitset<64> bitset {};

		//we simply iterate over all bytes/bits and copy them into the bitset
		//we have to respect byte endianess here
		if(littleEndian())
		{
			//for little endian we can simply copy the bits into the bitset bit by bit
			//the first bytes are the least significant ones, exactly as in the bitset
			for(auto i = 0u; i < channel.second; ++i)
			{
				//note that this does NOT extract the bit as position bitOffset but rather
				//the bitOffset-significant bit, i.e. we don't have to care about
				//bit-endianess in any way. We want less significant bits first and this is
				//what we get here (i.e. bitOffset will always only grow, therefore the
				//extracted bits will get more significant)
				bitset[i] = (*iter & (1 << bitOffset));

				++bitOffset;
				if(bitOffset >= 8)
				{
					++iter;
					bitOffset = 0;
				}
			}
		}
		else
		{
			//for big endian we have to swap the order in which we read bytes
			//but if we would simply inverse it, we would inverse all significance.
			//For e.g. a channel with 8 bits and value 0xFF, we want 0xFF and not 0x00...00FF
			//therefore we start at bitset position ((byteCount - 1) * 8), i.e. the least
			//significant byte that has data.
			//During the loop we always get more significant bit-wise and less significant
			//byte-wise.
			auto currentBit = (byteCount - 1) * 8;
			for(auto i = 0u; i < channel.second; ++i)
			{
				//note that we still want to store less significant data first and since
				//bitOffset (and currentBit) are (inside of one byte) only increasing we
				//we always extract only bits that are more significant than the ones before
				bitset[currentBit] = (*iter & (1 << bitOffset));

				++bitOffset;
				++currentBit;
				if(bitOffset >= 8)
				{
					++iter;
					++byteCount;
					currentBit -= 8; //jump back exactly one byte
					bitOffset = 0;
				}
			}
		}

		//to_ullong returns an unsigned long long that has the first bits from the
		//bitset as least significant bits and the last bits from the bitset as most
		//significant bits
		*val = bitset.to_ullong();
	}

	return rgba;
}

nytl::Vec4f norm(nytl::Vec4u64 color, const ImageFormat& format)
{
	nytl::Vec4f ret = color;

	for(auto& channel : format)
	{
		if(!channel.second) continue;

		switch(channel.first)
		{
			case ColorChannel::red: ret[0] /= std::exp2(channel.second) - 1; break;
			case ColorChannel::green: ret[1] /= std::exp2(channel.second) - 1; break;
			case ColorChannel::blue: ret[2] /= std::exp2(channel.second) - 1; break;
			case ColorChannel::alpha: ret[3] /= std::exp2(channel.second) - 1; break;
			case ColorChannel::none: continue;
		}
	}

	return ret;
}

void writePixel(uint8_t& pixel, const ImageFormat& format, nytl::Vec4u8 color,
	unsigned int bitOffset)
{
	auto pixelSize = byteSize(format);
}

}
