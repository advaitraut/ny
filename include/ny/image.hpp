// Boost Software License - Version 1.0 - August 17th, 2003
//
// Copyright (c) 2015-2016 nyorain
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#pragma once

#include <nytl/vec.hpp>
#include <memory>
#include <cstring>

namespace image
{

///Represents a ColorChannel for an ImageFormat specification.
enum class ColorChannel
{
	none,
	red,
	green,
	blue,
	alpha
};

using ImageFormat = std::array<std::pair<ColorChannel, uint8_t>, 9>;

///Returns the number of bits needed to store one pixel in the given format.
unsigned int bitSize(const ImageFormat& format)
{
	auto ret = 0u;
	for(auto& channel : format) ret += channel.second;
	return ret;
}
unsigned int byteSize(const ImageFormat& format)
{
	return std::ceil(bitSize(format) / 8.0);
}

ImageFormat toggleByteWordOrder(const ImageFormat& format);

constexpr ImageFormat rgba8888 {{
	{ColorChannel::red, 8},
	{ColorChannel::green, 8},
	{ColorChannel::blue, 8},
	{ColorChannel::alpha, 8},
}};

constexpr ImageFormat argb8888 {{
	{ColorChannel::alpha, 8},
	{ColorChannel::red, 8},
	{ColorChannel::green, 8},
	{ColorChannel::blue, 8},
}};

constexpr ImageFormat a8 {{{ColorChannel::alpha, 8}}};
constexpr ImageFormat a1 {{{ColorChannel::alpha, 1}}};

template<typename P> class BasicImage;

namespace detail
{
	template<typename P>
	void copy(P& to, uint8_t* from, unsigned int) { to = from; }

	template<typename PT>
	void copy(std::unique_ptr<PT[]> to, uint8_t* from, unsigned int size)
	{
		if(!from)
		{
			to = {};
			return;
		}

		to = std::make_unique<PT[]>(size);
		std::memcpy(to.get(), from, size);
	}
}

///Returns the next multiple of alignment that is greater or equal than value.
///Can be used to 'align' a value e.g. align(27, 8) returns 32.
template<typename A, typename B>
constexpr auto align(A value, B alignment)
	{ return std::ceil(value / double(alignment)) * alignment; }

///Used to pass loaded or created images to functions.
///Note that this class does explicitly not implement any functions for creating/loading/changing
///the image itself, it is only used to hold all information needed to correctly interpret
///a raw image data buffer.
///Its stride is stored in bits and therefore the image stride might not be a multiple
///of 8 bits (1 byte).
///There are several helper functions that make dealing with BasicImage objects easier.
///\tparam P The pointer type to used. Should be a type that can be used as std::uint8_t*.
///Might be const or a smart pointer.
template<typename P>
class BasicImage
{
public:
	BasicImage() = default;
	~BasicImage() = default;

	BasicImage(uint8_t& xdata, nytl::Vec2ui xsize, const ImageFormat& fmt, unsigned int strd = 0u)
		: size(xsize), format(fmt), stride(strd)
	{
		if(!stride) stride = size.x * bitSize(format);
		detail::copy(data, &xdata, dataSize(*this));
	}

	BasicImage(P xdata, nytl::Vec2ui xsize, const ImageFormat& fmt, unsigned int strd = 0u)
		: data(std::move(xdata)), size(xsize), format(fmt), stride(strd)
		{ if(!stride) stride = std::ceil(size.x * bitSize(format) / 8) * 8; }

	template<typename O>
	BasicImage(const BasicImage<O>& lhs)
		: size(lhs.size()), format(lhs.format()), stride(lhs.stride())
		{ detail::copy(data, lhs.data(), lhs.dataSize()); }

	template<typename O>
	BasicImage& operator=(const BasicImage<O>& lhs)
	{
		size = lhs.size;
		format = lhs.format;
		stride = lhs.sitrde;
		detail::copy(data, lhs.data(), lhs.dataSize());
		return *this;
	}

	BasicImage(BasicImage&&) = default;
	BasicImage& operator=(BasicImage&&) = default;

public:
	P data {}; //raw image data. At least dataSize() bytes.
	nytl::Vec2ui size {}; //size in pixels.
	ImageFormat format {}; //data format in word order (endian-native).
	unsigned int stride {}; //stride in bits.
};

using Image = BasicImage<const uint8_t*>;
using MutableImage = BasicImage<uint8_t*>;
using OwnedImage = BasicImage<std::unique_ptr<uint8_t[]>>;

///Returns the raw data from the given BasicImage as uint8_t pointer.
///Useful for generic code since it allows to access the raw data independently from the medium
///used to store it (could e.g. be a std::unique_ptr).
template<typename P>
const uint8_t* data(const BasicImage<P>& img)
	{ return img.data; }

template<typename P>
const uint8_t* data(const BasicImage<std::unique_ptr<P>>& img)
	{ return img.data.get(); }

///Returns the stride of the given BasicImage in bits.
///If the given image has no stride stored, calculates the stride.
template<typename P>
unsigned int bitStride(const BasicImage<P>& img)
	{ return img.stride ? img.stride : img.size.x * bitSize(img.format); }

///Returns the stride of the given BasicImage in bytes (rounded up).
///If the given image has no stride stored, calculates the stride.
template<typename P>
unsigned int byteStride(const BasicImage<P>& img)
	{ return img.stride ? std::ceil(img.stride / 8) : img.size.x * byteSize(img.format); }

///Returns the total amount of bytes the image data holds (rounded up).
template<typename P>
unsigned int dataSize(const BasicImage<P>& img)
	{ return std::ceil(bitStride(img) * img.size.y / 8.0); }

///Returns the color of the image at at the given position.
///Does not perform any range checking, i.e. if position lies outside of the size
///of the passed ImageData object, this call will result in undefined behavior.
nytl::Vec4u64 readPixel(const Image&, nytl::Vec2ui position);

///Returns the color of the given pixel value for the given ImageFormat.
///Results in undefined behaviour if the given format is invalid or the data referenced
///by pixel does not have enough bytes to read.
///\param bitOffset The bit position at which reading should start.
nytl::Vec4u64 readPixel(const uint8_t& pixel, const ImageFormat&, unsigned int bitOffset = 0u);

///Sets the color of the pixel at the given position.
///Does not perform any range checking, i.e. if position lies outside of the size
///of the passed ImageData object, this call will result in undefined behavior.
void writePixel(const MutableImage&, nytl::Vec2ui position, nytl::Vec4u8 color);

///Sets the color of the given pixel.
///Results in undefined behaviour if the given format is invalid or the data referenced
///by pixel does not have enough bytes to read.
///\param bitOffset The bit position at which reading should start.
void writePixel(uint8_t& pixel, const ImageFormat&, nytl::Vec4u64 color,
	unsigned int bitOffset = 0u);

///Returns whether the current machine is little endian.
///If this returns false it is assumed to be big endian (other types are ignored).
constexpr bool littleEndian();

/// - implementation -
constexpr bool littleEndian()
{
	constexpr uint32_t dummy = 1u;
	return (((std::uint8_t*)&dummy)[0] == 1);
}

nytl::Vec4u64 readPixel(const uint8_t& pixel, const ImageFormat& format, unsigned int bitOffset)
{
	const uint8_t* iter = &pixel;
	nytl::Vec4u64 rgba {};

	for(auto i = 0u; i < format.size(); ++i)
	{
		//for little endian channel order is inversed
		auto channel = (littleEndian()) ? format[format.size() - (i + 1)] : format[i];

		//calculate the byte count we have to load at all for this channel
		unsigned int byteCount = std::ceil((channel.second + bitOffset) / 8.0);

		uint64_t* val {};
		switch(channel.first)
		{
			case ColorChannel::red: val = &rgba[0]; break;
			case ColorChannel::green: val = &rgba[1]; break;
			case ColorChannel::blue: val = &rgba[2]; break;
			case ColorChannel::alpha: val = &rgba[3]; break;
			case ColorChannel::none: iter += byteCount; continue;
		}

		//load the first byteCount bytes as least significant bytes into *val
		//for big endian we have to reverse it because we want to load the first bytes of *iter
		//into the least signigicant (i.e. the last) bytes of *val
		if(littleEndian()) for(auto b = 0u; b < byteCount; ++b) val[b] = *(iter++);
		else for(auto b = 0u; b < byteCount; ++b) val[byteCount - (b + 1)] = *(iter++);

		//create a bitmask with the least significant channel.second bites set to 1
		uint64_t bitmask = 0u;
		for(auto m = 0u; m < channel.second && m < 64; ++m) bitmask |= (1 << m);

		//discard all bits from *val that are not in the range of the current channel
		*val = (*val >> bitOffset) & bitmask;

		//advance the bitOffset by the bits we read into the next byte.
		bitOffset = channel.second % 8;
	}

	return rgba;
}

void writePixel(uint8_t& pixel, const ImageFormat& format, nytl::Vec4u8 color,
	unsigned int bitOffset)
{
	auto pixelSize = byteSize(format);
}

}
